# ğŸ§­ Multi-Map Navigation with Wormholes in ROS 1 

## Overview

This ROS package demonstrates a **modular, action-based multi-map navigation system** for a mobile robot that seamlessly transitions between independently mapped rooms (maps) using a mechanism called **wormholes**.

Key features:
- Dynamic **room-to-room navigation**
- **SQL database** to store wormhole data
- Gazebo simulation and move_base navigation
- **Custom action server** for multi-map goal handling
- Automatic launch and shutdown of Gazebo + Nav Stack nodes

---

## ğŸ“Œ Problem Statement

Design and implement a system where:

- Each room is mapped separately.
- A robot can navigate to any location across rooms.
- A *wormhole* connects overlapping areas between rooms.
- Robot autonomously:
  - Navigates to the wormhole,
  - Switches map and Gazebo world,
  - Continues navigation in the new room.

---

## ğŸ—‚ï¸ Project Structure

multi_map_navigator/
â”œâ”€â”€ action/
â”‚ â””â”€â”€ NavigateBetweenMaps.action
â”œâ”€â”€ maps/
â”‚ â”œâ”€â”€ room_a.yaml
â”‚ â””â”€â”€ room_b.yaml
â”œâ”€â”€ world/
â”‚ â”œâ”€â”€ room_a.world
â”‚ â””â”€â”€ room_b.world
â”œâ”€â”€ launch/
â”‚ â”œâ”€â”€ amcl.launch
â”‚ â”œâ”€â”€ move_base.launch
â”‚ â”œâ”€â”€ my_world_loader.launch
â”‚ â””â”€â”€ my_navigation.launch
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ action_server.cpp
â”‚ â”œâ”€â”€ action_client.cpp
â”‚ â”œâ”€â”€ nav_controller.cpp
â”‚ â”œâ”€â”€ map_manager.cpp
â”‚ â””â”€â”€ db_interface.cpp
â”œâ”€â”€ include/
â”‚ â””â”€â”€ multi_map_navigator/
â”‚ â”œâ”€â”€ nav_controller.hpp
â”‚ â”œâ”€â”€ map_manager.hpp
â”‚ â””â”€â”€ db_interface.hpp
â”œâ”€â”€ param/
â”‚ â”œâ”€â”€ base_local_planner_params.yaml
â”‚ â”œâ”€â”€ costmap_common_params_burger.yaml
â”‚ â”œâ”€â”€ dwa_local_planner_params_burger.yaml
â”‚ â”œâ”€â”€ global_costmap_params.yaml
â”‚ â”œâ”€â”€ local_costmap_params.yaml
â”‚ â””â”€â”€ move_base_params.yaml
â”œâ”€â”€ rviz/
â”‚ â””â”€â”€ turtlebot3_navigation.rviz
â””â”€â”€ my_wormholes.db

---

## ğŸ§  Architecture

**Core Components:**

- `action_server.cpp`: Receives goal with pose + map ID, dispatches to `NavController`.
- `NavController`: Handles logic to either:
  - Navigate directly if in the same map.
  - Go to wormhole, shutdown current world, launch new one, continue navigation.
- `db_interface`: SQLite wrapper for reading wormhole positions.
- `map_manager`: Publishes initial pose after map switch.

**Inter-process Coordination:**
- Launch files for spawning Gazebo + navigation stack per map.
- Wormholes act as bridges between maps.
- Modular launch separation ensures extendability.

---

## ğŸš€ Execution Flow

1. **Client Node:**
   - Starts `my_world_loader.launch` and `my_navigation.launch`.
   - Sends a `NavigateBetweenMapsGoal` to the server.

2. **Server (Action):**
   - Checks if target map is same.
   - If not:
     - Moves to wormhole using `move_base`.
     - Kills current Gazebo and Nav stack.
     - Launches new `world_file` and `map_file`.
     - Sets initial pose via `map_manager`.
     - Sends final goal to `move_base`.

3. **Navigation is visualized in RViz.**

---

## âš™ï¸ How to Run

```bash
cd ~/multi_map_nav_ws
catkin_make
source devel/setup.bash
rosrun multi_map_navigator navigate_between_maps_server
rosrun multi_map_navigator navigate_between_maps_client
```

## ğŸ“¡ Wormhole DB Schema

`my_wormholes.db` contains:

```sql
CREATE TABLE wormholes (
  source_map TEXT,
  target_map TEXT,
  source_x REAL,
  source_y REAL,
  source_yaw REAL,
  target_x REAL,
  target_y REAL,
  target_yaw REAL
);
```

### ğŸ“‹ Pseudocode (C++ Style)

#### handleNavigation(...)

```cpp
if (target_map == current_map) {
    // Already in the desired map, send goal directly
    return sendGoal(target_pose);
}

// Step 1: Fetch wormhole details from SQLite DB
Wormhole wh = db.getWormhole(current_map, target_map);

// Step 2: Navigate to the wormhole pose in current map
sendGoal(wh.source_pose);

// Step 3: Kill old Gazebo and Navigation nodes
killGazeboAndNavStack();

// Step 4: Launch new world and map
launchNewWorld(target_map);
launchNavStack(target_map);

// Step 5: Set initial pose in new map using wormhole target
map_mgr.setInitialPose(wh.target_x, wh.target_y, wh.target_yaw);

// Step 6: Wait for new move_base to come up
waitForMoveBase();

// Step 7: Send final goal in the new map
return sendGoal(target_pose);
```

### ğŸ“‹ Pseudocode â€“ `sendGoal(...)`

```cpp
// Connect to move_base action server
wait for move_base;

// Send the goal
send goal;

// Wait for result
wait for result;

// Return outcome
if (success)
    return true;
else
    return false;
```

### ğŸ“Š Trajectory Handling

**Collection:**

Trajectories generated by `move_base` can be recorded using:

```bash
rosbag record /odom /move_base/TrajectoryPlannerROS/global_plan /tf
```

**Storage**
   - Navigation is dynamic and reactive.
   - Paths are computed live by move_base.
   - No pre-defined or statically stored trajectories are used.
   
**Visualization (RViz)**
   - View real-time robot movement
   - Set initial pose (`/initialpose`)
   - Send navigation goals (`2D Nav Goal`)
   - Track coordinate frames (`/tf`)
   - Observe global and local planned paths in RViz
   
### âœ… Modularity & OOP Principles
   - All core functionality is modular and separated into:
      - `NavController`: Handles decision flow and control logic.
      - `DBInterface`: Interfaces with the SQLite wormhole database.
      - `MapManager`: Publishes initial pose after map switch.
   - ROS parameters, file paths, and topic names are *externally configurable*.
   - To add new maps:
      - Just create new .yaml, .world, and a DB entry â€” no code change needed.
### ğŸ“¦ Dependencies
   - ROS Noetic
   - `move_base`, `amcl`, `map_server`
   - `gazebo_ros`, `turtlebot3_description`
   - SQLite3 (system library)
```bash
sudo apt-get install libsqlite3-dev sqlite3
```
